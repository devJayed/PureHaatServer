import { StatusCodes } from "http-status-codes";
import QueryBuilder from "../../builder/QueryBuilder";
import AppError from "../../errors/appError";
import { IImageFiles } from "../../interface/IImageFile";
import { IJwtPayload } from "../auth/auth.interface";
import { Category } from "../category/category.model";
import { FlashSale } from "../flashSell/flashSale.model";
import { Review } from "../review/review.model";
import User from "../user/user.model";
import { IProduct } from "./product.interface";
import { Product } from "./product.model";

const createProduct = async (
  productData: Partial<IProduct>,
  productImages: IImageFiles
) => {
  console.log("Product Data Backend:", { productData });
  const { images } = productImages;
  if (!images || images.length === 0) {
    throw new AppError(StatusCodes.BAD_REQUEST, "Product images are required.");
  }

  productData.images = images.map((image) => ({
    url: image.path,
    altText: image.originalname || "",
  }));

  const isCategoryExists = await Category.findById(productData.category);
  if (!isCategoryExists) {
    throw new AppError(StatusCodes.BAD_REQUEST, "Category does not exist!");
  }

  if (!isCategoryExists.isActive) {
    throw new AppError(StatusCodes.BAD_REQUEST, "Category is not active!");
  }

  const newProduct = new Product({
    ...productData,
  });

  const result = await newProduct.save();
  return result;
};

// const getAllProduct = async (query: Record<string, unknown>) => {
//   const { minPrice, maxPrice, ...pQuery } = query;

//   const productQuery = new QueryBuilder(
//     Product.find().populate("category", "name"),
//     pQuery
//   )
//     .search(["name", "description"])
//     .filter()
//     .sort()
//     .paginate()
//     .fields()
//     .priceRange(Number(minPrice) || 0, Number(maxPrice) || Infinity);

//   const products = await productQuery.modelQuery.lean();

//   const meta = await productQuery.countTotal();

//   const productIds = products.map((product: any) => product._id);

//   const flashSales = await FlashSale.find({
//     product: { $in: productIds },
//     discountPercentage: { $gt: 0 },
//   }).select("product discountPercentage");

//   const flashSaleMap = flashSales.reduce(
//     (acc, { product, discountPercentage }) => {
//       //@ts-ignore
//       acc[product.toString()] = discountPercentage;
//       return acc;
//     },
//     {}
//   );

//   const updatedProducts = products.map((product: any) => {
//     //@ts-ignore
//     const discountPercentage = flashSaleMap[product._id.toString()];
//     if (discountPercentage) {
//       product.offerPrice = product.price * (1 - discountPercentage / 100);
//     } else {
//       product.offerPrice = null;
//     }
//     return product;
//   });

//   return {
//     meta,
//     result: updatedProducts,
//   };
// };

// Product.service.ts

// Use this section

const getAllProduct = async (query: Record<string, unknown>) => {
  const { minPrice, maxPrice, categories, inStock, ratings, ...pQuery } = query;

  // Build the filter object
  const filter: Record<string, any> = {};

  // Filter by categories
  if (categories) {
    const categoryArray =
      typeof categories === "string"
        ? categories.split(",")
        : Array.isArray(categories)
        ? categories
        : [categories];
    filter.category = { $in: categoryArray };
  }

  // Filter by in stock/out of stock
  if (inStock !== undefined) {
    filter.stock = inStock === "true" ? { $gt: 0 } : 0;
  }

  // Filter by ratings
  if (ratings) {
    const ratingArray =
      typeof ratings === "string"
        ? ratings.split(",")
        : Array.isArray(ratings)
        ? ratings
        : [ratings];
    filter.averageRating = { $in: ratingArray.map(Number) };
  }

  const productQuery = new QueryBuilder(
    Product.find(filter).populate("category", "name"),
    pQuery
  )
    .search(["name", "description"])
    .filter()
    .sort()
    .paginate()
    .fields()
    .priceRange(Number(minPrice) || 0, Number(maxPrice) || Infinity);

  const products = await productQuery.modelQuery.lean();

  const meta = await productQuery.countTotal();

  // Get Flash Sale Discounts
  const productIds = products.map((product: any) => product._id);

  const flashSales = await FlashSale.find({
    product: { $in: productIds },
    discountPercentage: { $gt: 0 },
  }).select("product discountPercentage");

  const flashSaleMap = flashSales.reduce(
    (acc, { product, discountPercentage }) => {
      //@ts-ignore
      acc[product.toString()] = discountPercentage;
      return acc;
    },
    {}
  );

  // Add offer price to products
  const updatedProducts = products.map((product: any) => {
    //@ts-ignore
    const discountPercentage = flashSaleMap[product._id.toString()];
    if (discountPercentage) {
      product.offerPrice = product.price * (1 - discountPercentage / 100);
    } else {
      product.offerPrice = null;
    }
    return product;
  });

  return {
    meta,
    result: updatedProducts,
  };
};

// const getTrendingProducts = async (limit: number) => {
//    const now = new Date();
//    const last30Days = new Date(now.setDate(now.getDate() - 30));

//    const trendingProducts = await Order.aggregate([
//       {
//          $match: {
//             createdAt: { $gte: last30Days },
//          },
//       },
//       {
//          $unwind: '$products',
//       },
//       {
//          $group: {
//             _id: '$products.product',
//             orderCount: { $sum: '$products.quantity' },
//          },
//       },
//       {
//          $sort: { orderCount: -1 },
//       },
//       {
//          $limit: limit || 10,
//       },
//       {
//          $lookup: {
//             from: 'products',
//             localField: '_id',
//             foreignField: '_id',
//             as: 'productDetails',
//          },
//       },
//       {
//          $unwind: '$productDetails',
//       },
//       {
//          $project: {
//             _id: 0,
//             productId: '$_id',
//             orderCount: 1,
//             name: '$productDetails.name',
//             price: '$productDetails.price',
//             offer: '$productDetails.offer',
//             imageUrls: '$productDetails.imageUrls',
//          },
//       },
//    ]);

//    return trendingProducts;
// };

const getSingleProduct = async (productId: string) => {
  // console.log(productId);
  const product = await Product.findById(productId).populate("category");

  if (!product) {
    throw new AppError(StatusCodes.NOT_FOUND, "Product not found");
  }

  if (!product.isActive) {
    throw new AppError(StatusCodes.BAD_REQUEST, "Product is not active");
  }

  const offerPrice = await product.calculateOfferPrice();
  const reviews = await Review.find({ product: product._id });

  const productObj = product.toObject();

  return {
    ...productObj,
    offerPrice,
    reviews,
  };
};

// const getMyShopProducts = async (query: Record<string, unknown>, authUser: IJwtPayload) => {
//    const userHasShop = await User.findById(authUser.userId).select('isActive hasShop');

//    if (!userHasShop) throw new AppError(StatusCodes.NOT_FOUND, "User not found!");
//    if (!userHasShop.isActive) throw new AppError(StatusCodes.BAD_REQUEST, "User account is not active!");
//    if (!userHasShop.hasShop) throw new AppError(StatusCodes.BAD_REQUEST, "User does not have any shop!");

//    const shopIsActive = await Shop.findOne({
//       user: userHasShop._id,
//       isActive: true
//    }).select("isActive");

//    if (!shopIsActive) throw new AppError(StatusCodes.BAD_REQUEST, "Shop is not active!");

//    const { minPrice, maxPrice, ...pQuery } = query;

//    const productQuery = new QueryBuilder(
//       Product.find({ shop: shopIsActive._id })
//          .populate('category', 'name')
//          .populate('shop', 'shopName')
//          .populate('brand', 'name'),
//       pQuery
//    )
//       .search(['name', 'description'])
//       .filter()
//       .sort()
//       .paginate()
//       .fields()
//       .priceRange(Number(minPrice) || 0, Number(maxPrice) || Infinity);

//    const products = await productQuery.modelQuery.lean();

//    const productsWithOfferPrice = await Promise.all(
//       products.map(async (product) => {
//          const productDoc = await Product.findById(product._id);
//          const offerPrice = productDoc?.offerPrice;
//          return {
//             ...product,
//             offerPrice: Number(offerPrice) || null,
//          };
//       })
//    );

//    const meta = await productQuery.countTotal();

//    return {
//       meta,
//       result: productsWithOfferPrice,
//    };
// };

const updateProduct = async (
  productId: string,
  payload: Partial<IProduct>,
  productImages: IImageFiles,
  authUser: IJwtPayload
) => {
  const { images } = productImages;

  const user = await User.findById(authUser.userId);

  const product = await Product.findOne({
    _id: productId,
  });

  if (!user?.isActive) {
    throw new AppError(StatusCodes.BAD_REQUEST, "User is not active");
  }

  if (!product) {
    throw new AppError(StatusCodes.NOT_FOUND, "Product Not Found");
  }

  if (images && images.length > 0) {
    payload.images = images.map((image) => ({
      url: image.path,
      altText: image.originalname || "", // optional
    }));
  }

  return await Product.findByIdAndUpdate(productId, payload, { new: true });
};

const deleteProduct = async (productId: string, authUser: IJwtPayload) => {
  // console.log({productId});
  const user = await User.findById(authUser.userId);

  const product = await Product.findOne({
    _id: productId,
  });

  if (!user?.isActive) {
    throw new AppError(StatusCodes.BAD_REQUEST, "User is not active");
  }
  if (!product) {
    throw new AppError(StatusCodes.NOT_FOUND, "Product Not Found");
  }

  return await Product.findByIdAndDelete(productId);
};

export const ProductService = {
  createProduct,
  getAllProduct,
  // getTrendingProducts,
  getSingleProduct,
  updateProduct,
  deleteProduct,
  // getMyShopProducts
};
